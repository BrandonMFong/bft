#!/usr/bin/python3

__author__ = "brando"
__date__ = "12/2/24"

import argparse # https://docs.python.org/3/library/argparse.html
import sys
import os
import requests
import json
import tarfile

SCRIPT_NAME = sys.argv[0]
SCRIPT_PATH = os.path.dirname(os.path.realpath(__file__))
VERBOSE = True

def debug_print(buf):
    if VERBOSE:
        print(buf)

def bft_reg_url():
    return "https://raw.githubusercontent.com/BrandonMFong/bft-buckets/refs/heads/dev/buckets/"

class Package():
    """
    The package file that gets downloaded from download entry
    """
    def __init__(self, file_path):
        self._file_path = file_path

    def extract(self, target_dir):
        debug_print("extractping {} to {}".format(self._file_path, target_dir))
        if self._file_path.endswith("tar.gz"):
            debug_print("identified as a tar.gz file")
            tar = tarfile.open(self._file_path, "r:gz")
            debug_print(tar.getmembers())
            tar.extractall(path=target_dir)
            tar.close()

class BucketMeta():
    """
    Handles parsing the bucket recipe
    """
    def __init__(self, bucket_file_url):
        self._bucket_file_url = bucket_file_url
        self.__get_meta()

    def __get_meta(self):
        url = self._bucket_file_url
        debug_print("downloading bucket description from url {}".format(url))
        response = requests.get(url)
        if response.status_code != 200:
            raise Exception("status code {}".format(response.status_code))
        
        debug_print("bucket content:")
        self._meta_bucket = response.json()
        debug_print(json.dumps(self._meta_bucket, indent=4))

        meta_url = response.json()["meta"]["url"]
        response = requests.get(meta_url)
        debug_print("downloading bucket metadata from url {}".format(meta_url))
        if response.status_code != 200:
            raise Exception("status code {}".format(response.status_code))
 
        debug_print("meta data:")
        self._meta_github_release = response.json()
        debug_print(json.dumps(self._meta_github_release, indent=4))

    def tag_name(self):
        return self._meta_github_release["tag_name"]

    def __platform(self):
        return "linux"

    def url_package(self):
        platform = self.__platform()
        return self._meta_bucket["download"][platform]["url"]

    def package_items(self):
        platform = self.__platform()
        return self._meta_bucket["download"][platform]["items"]

class Bucket():
    def __init__(self, name):
        self._name = name
        self._meta = BucketMeta(bft_reg_url() + self._name + ".json")

    def tag_name(self):
        return self._meta.tag_name()

    def name(self):
        return self._name

    def __url_package(self):
        return self._meta.url_package()

    def download(self, target_dir):
        # create tmp directory we are downloading to
        debug_print("downloading to target_dir {}...".format(target_dir))
        tmp_dir = os.path.join(target_dir, "tmp")
        create_dir(tmp_dir)

        # get the url we are downloading from
        url = self.__url_package()
        tmp_file = tmp_dir + "/" + os.path.basename(url)
        debug_print("downloading {} to {}".format(
            url, tmp_file
        ))

        # get the object from url
        # fetch with progress
        debug_print("fetching {}".format(url))
        response = requests.get(url)
        if response.status_code != 200:
            raise Exception("status code {}".format(response.status_code))

        # write content to a file
        with open(tmp_file, mode="wb") as file:
            file.write(response.content)

        if os.path.getsize(tmp_file) == 0:
            raise Exception("{} is empty".format(tmp_file))

        # extract items from package file
        bucket_pkg = Package(tmp_file)
        bucket_pkg.extract(tmp_dir)
        bin_dir = os.path.join(target_dir, "bin")
        create_dir(bin_dir)
        for item in self._meta.package_items():
            src = os.path.join(tmp_dir, item)
            dest = os.path.join(bin_dir, os.path.basename(item))
            debug_print("{} -> {}".format(src, dest))
            os.rename(src, dest)

def create_dir(d):
    debug_print("creating directory '{}'".format(d))
    try:
        os.mkdir(d)
    except:
        pass

def install_exec(args):
    debug_print("installing...")
    debug_print("bucket to install {}".format(args.buckets))
    for bucket_name in args.buckets:
        remote_bucket = Bucket(bucket_name)
        debug_print("remote bucket tag_name: {}".format(remote_bucket.tag_name()))
        
        target_dir = SCRIPT_PATH + "/pool"
        create_dir(target_dir)

        remote_bucket.download(target_dir)

def arguments_read():
    parser = argparse.ArgumentParser(
        prog=SCRIPT_NAME,
        description='Bucket Fetcher Tool',
        epilog='Copyright Â© 2024 Brando. All rights reserved.'
    )

    parser.add_argument('install', help='installs bucket')
    parser.add_argument('buckets', nargs=1, help='name of the bucket to install')

    return parser.parse_args()

def main():
    args = arguments_read()
    debug_print(args)
    if args.install:
        install_exec(args)

if __name__ == "__main__":
    main()

