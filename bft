#!/usr/bin/python3

__author__ = "brando"
__date__ = "12/2/24"

import argparse # https://docs.python.org/3/library/argparse.html
import sys
import os
import requests
import json
import tarfile
import platform
import shutil
import dmglib

SCRIPT_NAME = os.path.basename(sys.argv[0])
SCRIPT_PATH = os.path.dirname(os.path.realpath(__file__))
VERBOSE = True

class Argument():
    def __init__(self, commands, description):
        """
        commands : a list of acceptable commands. where the first will be the recommended arg to use
        """
        self.commands = commands
        self.description = description

ARG_INSTALL = Argument(["install"], "installs tool")
ARG_LIST = Argument(["list"], "lists available and installed content")

def debug_print(buf):
    """
    conditional print on verbose flag
    """
    if VERBOSE:
        print(buf)

class Arguments():
    def print_help():
        print("usage: {} <command> [<args>]".format(SCRIPT_NAME))
        print()
        print("command:")
        print(" {}\t{}".format(ARG_INSTALL.commands[0], ARG_INSTALL.description)) 
        print(" {}\t\t{}".format(ARG_LIST.commands[0], ARG_LIST.description)) 
        print()
        print("Copyright © 2024 Brando. All rights reserved.")

    def __init__(self):
        self._install = False
        self._list = False
        for arg in sys.argv:
            if arg in ARG_INSTALL.commands:
                self._install = True
            elif arg in ARG_LIST.commands:
                self._list = True

    def show_help(self):
        #return self._install is False and self._list is False
        return len(sys.argv) == 1

    def do_list(self):
        return self._list

    def do_install(self):
        return self._install

    def install_target(self):
        return [sys.argv[len(sys.argv) - 1]]

def bft_reg_url():
    """
    raw root folder to buckets
    """
    return "https://raw.githubusercontent.com/BrandonMFong/bft-buckets/refs/heads/dev/buckets/"

class Package():
    """
    The package file that gets downloaded from download entry
    """
    def __init__(self, file_path):
        self._file_path = file_path

    def extract(self, target_dir):
        """
        extracts everything in the package file
        """
        debug_print("extracting {} to {}".format(self._file_path, target_dir))
        if self._file_path.endswith("tar.gz"):
            debug_print("identified as a tar.gz file")
            tar = tarfile.open(self._file_path, "r:gz")
            debug_print(tar.getmembers())
            tar.extractall(path=target_dir)
            tar.close()
        elif self._file_path.endswith(".dmg"):
            dmg = dmglib.DiskImage(self._file_path)
            if dmg.has_license_agreement():
                raise Exception("cannot open {}".format(self._file_path))

            for mount_point in dmg.attach():
                shutil.copytree(mount_point, os.path.join(target_dir, os.path.basename(mount_point)))

            dmg.detach()

class BucketMeta():
    """
    Handles parsing the bucket recipe
    """
    def __init__(self, bucket_file_url):
        self._bucket_file_url = bucket_file_url
        self.__get_meta()

    def __get_meta(self):
        """
        compiles all the meta data from the bft-buckets buckets directory and
        every buckets' meta url
        """
        url = self._bucket_file_url
        debug_print("downloading bucket description from url {}".format(url))
        headers = {'Cache-Control': 'no-cache'}
        response = requests.get(url, headers=headers)
        if response.status_code != 200:
            raise Exception("status code {}".format(response.status_code))
        
        debug_print("bucket content:")
        self._meta_bucket = response.json()
        debug_print(json.dumps(self._meta_bucket, indent=4))

        meta_url = response.json()["meta"]["url"]
        response = requests.get(meta_url, headers=headers)
        debug_print("downloading bucket metadata from url {}".format(meta_url))
        if response.status_code != 200:
            raise Exception("status code {}".format(response.status_code))
 
        debug_print("meta data:")
        self._meta_github_release = response.json()
        debug_print(json.dumps(self._meta_github_release, indent=4))

    def tag_name(self):
        """
        returns tag_name from the github latest release api
        """
        return self._meta_github_release["tag_name"]

    def __platform(self):
        """
        returns the download's subkey that determines
        what package to download for the current platform
        """
        if platform.system() == "Linux":
            return "linux"
        elif platform.system() == "Darwin":
            return "macos"

    def url_package(self):
        """
        download url
        """
        platform = self.__platform()
        return self._meta_bucket["download"][platform]["url"]

    def package_items(self):
        """
        items from the package we are extracting
        """
        platform = self.__platform()
        return self._meta_bucket["download"][platform]["items"]

class Bucket():
    """
    A bucket is the package that we are installing/updating
    """
    def __init__(self, name):
        self._name = name
        self._meta = BucketMeta(bft_reg_url() + self._name + ".json")

    def tag_name(self):
        """
        returns the tag_name set for the release
        """
        return self._meta.tag_name()

    def name(self):
        """
        name of the bucket. Usually the basename of the
        bucket file without the extension
        """
        return self._name

    def __url_package(self):
        """
        the url entry under meta
        """
        return self._meta.url_package()

    def download(self, target_dir):
        """
        downloads the package
        """
        # create tmp directory we are downloading to
        debug_print("downloading to target_dir {}...".format(target_dir))
        tmp_dir = os.path.join(target_dir, "tmp")
        shutil.rmtree(tmp_dir, ignore_errors=True)
        create_dir(tmp_dir)

        # get the url we are downloading from
        url = self.__url_package()
        tmp_file = tmp_dir + "/" + os.path.basename(url)
        debug_print("downloading {} to {}".format(
            url, tmp_file
        ))

        # get the object from url
        # fetch with progress
        debug_print("fetching {}".format(url))
        headers = {'Cache-Control': 'no-cache'}
        response = requests.get(url, headers=headers)
        if response.status_code != 200:
            raise Exception("status code {}".format(response.status_code))

        # write content to a file
        with open(tmp_file, mode="wb") as file:
            file.write(response.content)

        if os.path.getsize(tmp_file) == 0:
            raise Exception("{} is empty".format(tmp_file))

        # extract items from package file
        bucket_pkg = Package(tmp_file)
        bucket_pkg.extract(tmp_dir)
        bin_dir = os.path.join(target_dir, "bin")
        create_dir(bin_dir)
        for item in self._meta.package_items():
            src = os.path.join(tmp_dir, item)
            dest = os.path.join(bin_dir, os.path.basename(item))
            debug_print("{} -> {}".format(src, dest))
            os.rename(src, dest)

def create_dir(d):
    """
    creates directory if it doesn't exist
    """
    debug_print("creating directory '{}'".format(d))
    try:
        os.mkdir(d)
    except:
        pass

def install_exec(args):
    """
    does installation
    """
    debug_print("installing...")
    debug_print("bucket to install {}".format(args.install_target))
    #for bucket_name in args.buckets:
    for bucket_name in args.install_target():
        remote_bucket = Bucket(bucket_name)
        debug_print("remote bucket tag_name: {}".format(remote_bucket.tag_name()))
        
        target_dir = SCRIPT_PATH + "/pool"
        create_dir(target_dir)

        remote_bucket.download(target_dir)

def arguments_read():
    """
    reads arguments
    """
    parser = argparse.ArgumentParser(
        prog=SCRIPT_NAME,
        description='Bucket Fetcher Tool',
        epilog='Copyright © 2024 Brando. All rights reserved.'
    )

    parser.add_argument('install', help='installs bucket')
    parser.add_argument('buckets', nargs=1, help='name of the bucket to install')
    
    parser.add_argument('list', help='list available buckets')

    return parser.parse_args()

def main():
    args = Arguments()
    
    if args.show_help():
        Arguments.print_help()
    elif args.do_install():
        install_exec(args)

if __name__ == "__main__":
    main()

